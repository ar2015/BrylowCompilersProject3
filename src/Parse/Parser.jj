PARSER_BEGIN(Parser)
	public class Parser{}
PARSER_END(Parser)

// LexSpec starts here

//white space

{
  " " | "\t" | "\n" | "\r" | "\f"
}

//reserved words

TOKEN :
{
  < "(" >
| < ")" >
| < "Absyn" >
| < "AddExpr" >
| < "AndExpr" >
| < "ArrayExpr" >
| < "ArrayType" >
| < "AssignableExpr" >
| < "AssignStmt" >
| < "BinOpExpr" >
| < "BlockStmt" >
| < "BooleanType" >
| < "CallExpr" >
| < "ClassDecl" >
| < "DivExpr" >
| < "EqualExpr" >
| < "Expr" >
| < "FalseExpr" >
| < "FieldExpr" >
| < "Formal" >
| < "GreaterExpr" >
| < "IdentifierExpr" >
| < "IdentifierType" >
| < "IfStmt" >
| < "IntegerLiteral" >
| < "IntegerType" >
| < "LesserExpr" >
| < "MethodDecl" >
| < "MulExpr" >
| < "NegExpr" >
| < "NewArrayExpr" >
| < "NewObjectExpr" >
| < "NotEqExpr" >
| < "NotExpr" >
| < "NullExpr" >
| < "OrExpr" >
| < "Program" >
| < "Stmt" >
| < "StringLiteral" >
| < "SubExpr" >
| < "ThisExpr" >
| < "ThreadDecl" >
| < "TrueExpr" >
| < "TrueExpr" >
| < "Type" >
| < "VarDecl" >
| < "VoidDecl" >
| < "WhileStmt" >
| < "XinuCallExpr" >
| < "XinuCallStmt" >
| < "public_static_void" >
| < "Thread" >
| < "synchronized" >
| < "AbstractList" >
| < "null" >
}

//comments

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

//literals

TOKEN :
{
  < INT: ( ["1"-"9"] (["0"-"9"])* | "0" )  >
| < OCT: ( "0"["0"-"7"] (["0"-"7"])* ) >
| < HEX: ( "0x"(["0"-"9"]|["A"-"F"]|["a"-"f"]) (["0"-"9"]|["A"-"F"]|["a"-"f"])*) >

| < STRING:
 "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

//identifiers

TOKEN :
{
  < ID: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER: ["A"-"Z","a"-"z","_","$"] >
| < #DIGIT: ["0"-"9"] >
}

<DEFAULT>
SKIP :
{
   <~[]> { error("Illegal token"); }
}

Absyn.Program Program() :
{ 
  Absyn.ClassDecl cd; 
  Absyn.ThreadDecl td;
  Absyn.MainClassDecl mcd;
  AbstractList<Absyn.ClassDecl> cds = new AbstractList<Absyn.ClassDecl>();
  AbstractList<Absyn.ThreadDecl> tds = new AbstractList<Absyn.ThreadDecl>();}
{
  mcd = MainClassDecl() 
	(cd = ClassDecl() { cds.add(cd);} | td = ThreadDecl() { tds.add(td);})* <EOF>
//  cd = ClassDecl()
//	("class" <ID>"{" "public" "static" "void" "main" "(" "String" "[" "]" <ID> ")" "{" (VarDecl())* (Stmt())* (cd1 = ClassDecl() | td = ThreadDecl())*) <EOF> {}
  { return new Absyn.Program(cds,tds); }
}

Absyn.ClassDecl MainClassDecl:
{ 
  Absyn.VarDecl vd;
  AbstractList<Absyn.VarDecl> vds = new AbstractList<Absyn.VarDecl>();
  Absyn.Stmt st;
  AbstractList<Absyn.Stmt> sts = new AbstractList<Absyn.Stmt>(); 
}

{
 "class" <ID> "{" "public" "static" "void" "main" "(" "String" "[" "]" <ID> ")" "{" ( vd = VarDecl() {vds.add(vd);} )* ( st = Stmt() {sts.add(st);} )* "}" "}"
 {return new Absyn.MainClassDecl(vds,sts);
}

Absyn.ClassDecl ClassDecl:
{ 
  Token name = null; parent = null;
  Absyn.FieldExpr fe;
  AbstractList<Absyn.FieldExpr> fes = new AbstractList<Absyn.FieldExpr>();
  Absyn.MethodDecl md;
  AbstractList<Absyn.MethodDecl> mds = new AbstractList<Absyn.MethodDecl>();
  Absyn VoidDecl vd;
  AbstractList<Absyn.VoidDecl> vds = new AbstractList<Absyn.VoidDecl>();
}
{
  "class" name = <ID> ("extends" <ID>)? "{" ( fe = FieldExpr() { fes.add(fe);} | md = MethodDecl() { mds.add(md);} | vd = VoidDecl() { vds.add(vd);})* "}"
  {return new Absyn.ClassDecl(name,parent,fes,mds,vs);}	
}

Absyn.ThreadDecl ThreadDecl:
{
  Token name = null; parent = null;
  Absyn.FieldExpr fe;
  AbstractList<Absyn.FieldExpr> fes = new AbstractList<Absyn.FieldExpr>();
  Absyn.MethodDecl md;
  AbstractList<Absyn.MethodDecl> mds = new AbstractList<Absyn.MethodDecl>();
  Absyn VoidDecl vd;
  AbstractList<Absyn.VoidDecl> vds = new AbstractList<Absyn.VoidDecl>();
 }
{
  "class" <ID> "extends" "Thread" "{" ( fe = FieldExpr() { fes.add(fe);} | md = MethodDecl() { mds.add(md);} | vd = VoidDecl() { vds.add(vd);})* "}"
  {return new Absyn.ThreadDecl(fes,mds,vds);}
}

Absyn.VarDecl VarDecl:
{
  Token name = null;
  Absyn.Type type;
  Absyn.Expr expr;
}
{
  type = Type() name = <ID> ("=" expr = Expr() ";" {return new VarDecl(name,type,expr);}
			| ";"               	   {return new VarDecl(name,type,expr);} )             
}

Absyn.MethodDecl MethodDecl:
{
  Token name = null;
  Absyn.Type mtype;
  Absyn.Type arg;
  AbstractList<Absyn.Type> args = new AbstractList<Absyn.Type>;
  Absyn.VarDecl vd;
  AbstractList<Absyn.VarDecl> vds = new AbstractList<Absyn.VarDecl>();
  Absyn.Expr returnexp;
  Absyn.Stmt st;
  AbstractList<Absyn.Stmt> sts = new AbstractList<Absyn.Stmt>();
}
{
  "public" mtype = Type() name =  <ID> "(" ( "synchronized" )? ( vd = VarDecl() { vds.add(vd); } ( "," vd = VarDecl() {vds.add(vd);} )* )? ")" "{" (vd = VarDecl() {vds.add(vd);} )* (st = Stmt() {sts.add(st);} )* "return" returnexp = Expr() ";" "}"
  { return new MethodDecl(name,mtype,args,sts,vds,returnexp);} 
}

Absyn.VoidDecl VoidDecl:
{
  Token name = null;
  Absyn.VarDecl vd;
  AbstractList<Absyn.VarDecl> vds = new AbstractList<Absyn.VarDecl>();
  Absyn.Stmt st;
  AbstractList<Absyn.Stmt> sts = new AbstractList<Absyn.Stmt>();
}
{
  "public" "void" name = <ID> "(" ")" "{" ( vd = VarDecl() { vds.add(vd); } )* (st = Stmt() {sts.add(st);} )* "}"
  { return new VoidDecl(name,vds,sts); } 
}

Absyn.FieldDecl FieldDecl:
{
  Absyn.Type type;
  Token name = null;
}
{
   type = Type() name = <ID> ";"
   { return new FieldDecl(type,name); } 
}

Absyn.Type Type() :
{
 Absyn.Type t;
}
{
   (LOOKAHEAD(ArrayType())      t = ArrayType()   |
    LOOKAHEAD(BooleanType())    t = BooleanType() |
    LOOKAHEAD(IntegerType())    t = IntegerType() |
    LOOKAHEAD(IdentifierType()) t = IdentifierType() )
{
        return t;
}
}

Absyn.Type ArrayType():
{ Absyn.Type t; }
{
  t = Type()
  { return new Absyn.ArrayType(t); }
}

Absyn.Type BooleanType() :
{}
{
  { return new Absyn.BooleanType(); }
}

Absyn.Type IntegerType() :
{}
{
  { return new Absyn.IntegerType(); }
}

Absyn.Type IdentifierType() :
{ Token t; }
{
        t = <ID>
        { return new Absyn.IdentifierType(t.image); }
}

Absyn.Stmt Stmt() :
{
        Absyn.Stmt s;
}
{
   (
    s = AssignStmt() |
    s = BlockStmt() |
    s = IfStmt() |
    s = XinuCallStmt() |
    s = WhileStmt()
   )
   { return s; }
}

